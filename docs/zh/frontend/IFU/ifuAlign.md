## ifu的权衡与配合
简单说明一下IBuffer的入队原理，IBuffer是先进先出的队列。enqPtr代表当前的IBuffer可入队第一项entry位置，enqPtr + 1代表当前的IBuffer可入队第二项的entry位置。如果IFU提供给IBuffer的是稀疏的有效指令，则IBuffer第一项可入队的entry需要从IFU提供的稀疏有效指令中选出第一项有效指令。则IBuffer第二项可入队的entry需要从IFU提供的稀疏指令中选出第二项有效指令。极端的由于IFU最多提供32条指令，IBuffer的每一项都会面临32选1的尴尬境地。

那么IFU和IBuffer能否相互配合做出一种特殊的约定呢？实际上是可以的，IBuffer实现写分bank策略，给IBuffer队列每一项进行编号，获得ibuffer_mod_id = IBuffer编号%4。IFU提供的入队指令也进行编号，获得对应的ifu_mod_id = IFU编号%4。IBuffer的entry只从对应的IBuffer_mod_id === ifu_mod_id项中进行选择。真是美妙的想法，从32选1变成了8选1。这对吗？理论上是否可行？代价是什么？

理论上还需要进一步的推敲。从连续性角度角度讲，如果IBuffer的当前entry为ibuffer_mod_id = 3的项入队了，则IBuffer的下一项entry的ibuffer_mod_id = 0。如果你不打乱顺序的话，则要求IFU送入的有效指令是连续的，稀疏的指令排布会打破对应的默契。图形是最为直观的，我将为你画出第一点要求。OK，现在我们知道了要求一：IFU的输出指令要求的是有效指令连续。图形是最为直观的，我将为你画出第二点要求。

![有效指令紧密排布与稀疏排布对比](../figure/IFU/instr-align.svg)

![有效指令紧密对齐排布与紧密非对齐排布对比](../figure/IFU/instr-align1.svg)

代价：有效指令的排布，要求筛选出紧密排布的有效指令索引，IFU引入了相关的计算逻辑。权衡的艺术：相对于送入IBuffer时的每条指令携带的数据信息进行刷选，IFU计算指令索引需要的逻辑会少一点点。IFU将有效指令进行了紧密排列，意味着虽然有32个指令信息存储位置，但我们可以进行较为精细的时钟门控操作。偏移计算，这要求提前掌控IBuffer的入队指针，实际上偏移计算本身会带来一定的计算量。不过相对好些的是需要进行偏移计算的数据量较少。~~~ 偏移计算也许还能优化节省一点逻辑，但与功能没有关系了。

前文已经讨论过了有效指令筛选机制，现在我们讨论一下IFU有效指令的对齐，我们需要将第一条指令偏移到当前IBuffer入队指针enqPtr % 4对应的位置。所以最大偏移量是3，进行有效指令对齐的最大问题就是提前获取enqPtr的值。实际上我们能够做到这一点。enqPtr值实际上就是有效指令数量的不停累加。遇到后端重定向时，enqPtr的值复位为0。IFU能够确定送入IBuffer的有效指令数量，同时也会接收来自后端的重定向，因此我们可以提前计算prevIBufferEnqPtr，如下图所示：
![提前计算入队指针](../figure/IFU/prevIBufferEnqPtr.svg)