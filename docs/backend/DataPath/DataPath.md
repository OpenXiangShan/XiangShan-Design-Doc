# DataPath

- 版本：V2R2
- 状态：OK
- 日期：2025/01/15
- commit：[xxx](https://github.com/OpenXiangShan/XiangShan/tree/xxx)

## 术语说明

Table: 术语说明

| 缩写  | 全称                        | 描述                      |
| ---- | --------------------------- | ------------------------- |
| og   | operand generation          | 源操作数生成阶段           |
| v0   | vector register #0          | 向量0号逻辑寄存器          |
| vl   | vector length csr register  | 向量长度csr寄存器          |
| rc/reg cache | register file cache | 寄存器堆缓存               |


## 总体设计

### 整体框图

![整体框图](./figure/datapath.svg)

### 子模块列表

Table: 子模块列表

| 子模块                | 描述                                                      |
| --------------------- | --------------------------------------------------------- |
| IntRFWBCollideChecker | 整数寄存器堆写口仲裁器                                      |
| FpRFWBCollideChecker  | 浮点寄存器堆写口仲裁器                                      |
| VfRFWBCollideChecker  | 向量通用寄存器堆写口仲裁器                                  |
| V0RFWBCollideChecker  | 向量v0寄存器堆写口仲裁器                                    |
| VlRFWBCollideChecker  | 整数vl寄存器堆写口仲裁器                                    |
| IntRFReadArbiter      | 整数寄存器堆读口仲裁器                                      |
| FpRFReadArbiter       | 浮点寄存器堆读口仲裁器                                      |
| VfRFReadArbiter       | 向量通用寄存器堆读口仲裁器                                  |
| V0RFReadArbiter       | 向量v0寄存器堆读口仲裁器                                    |
| VlRFReadArbiter       | 向量vl寄存器堆读口仲裁器                                    |
| IntRegFile            | 整数寄存器堆                                               |
| FpRegFile             | 浮点寄存器堆                                               |
| VfRegFile             | 向量通用寄存器堆                                           |
| V0RegFile             | 向量v0寄存器堆                                             |
| VlRegFile             | 向量vl寄存器堆                                             |
| RegCache              | 整数寄存器堆缓存                                           |

### 接口列表

见接口文档


## 功能

### 整体功能

数据通路在流水线中位于发射之后，进入执行单元之前。数据通路接收来自整数、浮点、向量、访存发射队列每个出口的指令，这些每个出口会与执行单元的ExeUnit一一对应。数据通路负责为每条指令读取寄存器堆，构造立即数，在进入ExeUnit前生成最终的操作数。数据通路里含有寄存器堆的实体，也负责寄存器堆的读写仲裁，以及数据读出和写入。目前数据通路还设置了整数寄存器堆的缓存，负责一部分整数数据的读出。

DataPath模块是数据通路的核心部分，包含整个OG0流水级和OG1流水级的前半部分。在OG0流水级里，会进行指令间的读口端口仲裁，只有仲裁成功的指令才读取寄存器堆，进入OG1流水级；仲裁失败的指令会刷掉自身，向前级发出发射失败的回应信息，以及og0取消信号。在OG1流水级，指令拿到寄存器堆返回的数据，和其他状态信息一起发往后续模块。注意在DataPath里不会进行指令操作数的最终生成，只会拿到从寄存器堆，Reg Cache，PcTargetMem里读出的备选数据，最终数据会在外部的BypassNetwork里生成。

### 读写仲裁

由于采用发射后读寄存器堆，发射到数据通路中的指令数量会远远超过寄存器堆的读口和写口数量，因此需要进行仲裁，只让读仲裁成功的指令去读寄存器。

每个寄存器堆都有一个读仲裁器，读仲裁器接收所有指令的每个操作数的valid和读地址addr，分别返回一个ready作为仲裁是否成功的标记。只有当指令的操作数是对应的数据类型（整数、浮点、向量通用、v0、vl），并且数据来源为reg类型，才会将valid拉高，发起仲裁请求。如果某个操作数不需要读寄存器堆，对应的valid为0，此时ready总会返回1让其通过仲裁器。对于每条指令，只有其所有的操作数都仲裁通过，才被视为读仲裁成功。读仲裁器还会输出一组读请求，数量为寄存器堆的读口数量，内容为每个读口最后仲裁成功的读地址。这组读请求会被送到寄存器堆进行实际的数据读取。

每个寄存器堆都有一个写仲裁器，写仲裁器接收所有指令的每个操作数的valid，分别返回一个ready作为仲裁是否成功的标记。只有当指令的目的寄存器数据类型匹配，并且需要写寄存器，才会将valid拉高，发起仲裁请求。与读仲裁类似，不发起请求的指令总会收到ready=1让其通过仲裁。

读写仲裁器内部的仲裁逻辑放在二级模块进行具体介绍。

### 读寄存器堆

每个寄存器堆的读仲裁器会输出一组读请求，数量为寄存器堆的读口数量，内容为每个读口最后仲裁成功的读地址。这些地址在OG0阶段被送往寄存器堆，发起读请求。在OG1阶段，相应数据从寄存器堆的读数据通道送出。各个指令的操作数根据自身的数据类型，和使用的读口编号，从寄存器堆的读数据里选出自己的数据。

### 读Reg Cache

DataPath内设置了Reg Cache，可以缓存整数ExeUnit和Load ExeUnit最近写回的数据。Reg Cache不需要进行读写仲裁，其端口数与需要读写的操作数数量一一对应。如果指令操作数的数据来源为regcache类型，将会向Reg Cache发起读请求。在OG0阶段，将valid信号和指令自身携带的RC地址信号传给Reg Cache，在OG1阶段可以从对应的数据通道中拿到数据。

### 读PC

部分指令需要读取PC作为源操作数，PC存储在DataPath外部的PcTargetMem中。在OG阶段，DataPath首先筛选出需要PC的指令，将其ftq信息通过io.fromPcTargetMem接口向外部发起读请求。在OG1阶段，外部通过该接口返回读到的PC信息。

### 写寄存器堆

执行单元的写回结果会由外部模块WbDataPath进行汇总，打包为写请求的格式发到DataPath。DataPath会接收到io.fromIntWb、io.fromFpWb、io.fromVfWb、io.fromV0Wb、io.fromVlWb五个接口传回的写回信息，每个都对应各自的寄存器堆。每个接口的通道数量为寄存器堆的写口数，内容为写使能、写地址、写数据。出于时序考虑，这些信号会在DataPath内部打一拍，然后直接送往寄存器堆写端口。

### 写Reg Cache

Reg Cache的写回数据不是来自执行单元，而且来自旁路网络中执行单元写回两拍之后的数据。Reg Cache只接受整数ExeUnit和Load ExeUnit的数据，这些数据通过io.fromBypassNetwork接口传入，然后直接送往Reg Cache。

### 处理og0 cancel

在OG0阶段，指令会因为多种原因被取消，其中因为自身原因的取消被称为og0 cancel。指令被判定为og0 cancel有两种情况，一种是自身读或者写寄存器堆仲裁失败，另一种是og0 cancel传递。DataPath中会保存前一次og0 cancel的信息，这是一个与发射宽度相同的向量，每位代表对应指令是否发生了取消。如果某一指令为0执行延迟的指令，且发生了取消，那么就会在向量对应位置写1。下一拍的指令会将自身操作数的唤醒来源向量和取消信息的向量进行比较，如果发现来源指令上拍被取消了，说明现在自身也要被取消。

发生了og0 cancel的指令会把自己刷掉，不进入OG1阶段。除了发生og0 cancel，发生重定向刷新或者load cancel的指令也会将自己刷掉，不加入OG1阶段。不过只有发生og0 cancel的指令才向外发出og0 cancel信号，该信号与前面提到的DataPath内部保存的og0 cancel信息相同，通过io.og0Cancel接口传到外部，用于取消指令的消费者指令。

### 向发射队列发出回应

DataPath会向发射队列发出回应信息，告诉发射队列指令是否顺利发射到执行单元。在OG阶段，如果指令发生了og0 cancel，指令发射失败，需要给发射队列回应block状态，告诉发射队列需要重新发射指令；如果顺利通过OG0阶段，则不发送回应信息。在OG1阶段，指令不会因为自身原因被取消，只需要看后级是否能接收指令。如果不能接收，指令无法进入执行单元，需要给发射队列回应block状态。如果可以被接收，对于标量计算指令，指令就一定能成功执行，此时就可以向发射队列回应success状态，告诉发射队列可以清空对应的队列项；对于向量计算指令，在进入执行单元前还有一个OG2阶段，此时还不能确定一定能执行，需要向发射队列回应uncertain状态，让发射队列先保持不变；对于访存指令，其进入访存执行单元后才能确定能否成功指令，因此清空队列项的回应由访存部分发出，这里只向发射队列回应uncertain状态。


## 模块设计

### 二级模块 RFWBCollideChecker

#### 功能

各个寄存器堆都有一个写口仲裁器，负责进行写口的仲裁。写口仲裁器会收集所有可以写该寄存器堆的指令的请求（valid信号），然后分别返回是否仲裁成功的标记（ready信号）。

在仲裁器内部，会按照端口号分为多个端口仲裁器。每个端口仲裁器会收集写该端口的指令请求，比如如果指令使用i号端口写回该堆，那么其请求会被发到第i个端口仲裁器。

在端口仲裁器中，采用的是带保底的优先级仲裁策略。在配置功能单元时，各个单元配置寄存器堆写口时，除了端口号，也会配置一个优先级。如果某一时刻有多个指令同时发出写请求，那么端口仲裁器会让优先级更高的指令仲裁成功。

端口仲裁器保证，如果有指令没发出请求，那么其ready=1，认为仲裁成功；如果有多个指令同时发出请求，发出请求的里面只会有一个ready=1，仲裁成功。

端口仲裁配置了保底策略，它给每个指令分配了一个计数器，每当指令发出请求但仲裁失败，就会将计数器加1；每当指令发出请求并仲裁成功，就会将计数器清空。当计数器累积到最大值7后，会触发保底状态，保底状态下，所有非保底的指令请求会被屏蔽，然后进行优先级仲裁。当保底成功，指令得到成功仲裁，就会清空计数器，退出保底状态。

#### 整体框图

以浮点寄存器堆的写口仲裁器为例，内部结构如下图所示。

![整体框图](./figure/fpWArbiter.svg)

#### 接口列表

见接口文档

### 二级模块 RFReadArbiter

#### 功能

各个寄存器堆都有一个读口仲裁器，负责进行读口的仲裁。与写口仲裁器类似，读口仲裁器也会收集所有可以读该寄存器堆的操作数的请求，返回是否仲裁成功的标记。不同之处在于，读口仲裁器收集的请求中还会携带读地址，最后还会输出每个读端口最终仲裁成功的地址，这些地址后续会被送到寄存器堆进行读操作。

在仲裁器内部，同样按照端口号分为多个端口仲裁器分别仲裁。和写仲裁相同，每个端口仲裁器也同样采用带保底的优先级仲裁策略。每个端口最后输出的地址为发出请求且仲裁成功的操作数提供的地址，如果某一时刻没有读请求，最终地址是优先级最低操作数的地址。

#### 整体框图

读口仲裁器的结构与写口仲裁器基本相同，此处不再赘述，主要区别在于每个读请求会携带读地址，同时内部每个端口仲裁器还会输出一个最终地址。

#### 接口列表

见接口文档

### 二级模块 RegFile

#### 功能

DataPath中设置有5个物理寄存器堆，其中整数和浮点都是单独的一个堆，向量则被拆分为3个堆，用于减少端口数量和面积开销。其中VfRegFile为通用向量寄存器堆，保存向量#1-#31逻辑寄存器和一些临时寄存器的值。V0RegFile为v0寄存器堆，只保存向量#0逻辑寄存器的值。VlRegFile为vl寄存器堆，只保存向量vl CSR寄存器的值。

寄存器堆使用了分块设计，根据具体情况会被分为S=1、2、4块。分块是纵向的，即容量为N，元素大小为M-bit的寄存器堆会被分为S个N * (M / S)大小的寄存器堆。每个元素会被分到各个块里，在读取和写入寄存器堆时，都会同时读取和写入每个分块堆。

寄存器堆有R个读口，每个读口有地址raddr和数据rdata两个信号，没有读使能。在某一时刻提供读地址，寄存器堆将该地址打一拍，下一拍用地址去读取对应的数据，发送到数据接口。

寄存器堆有W个写口，每个写口有写使能wen、写地址waddr和写数据wdata三个信号。在某一时刻，如果wen拉高，那么对应地址会被写入所给的数据，写入的数据会在下一拍被看到。整数寄存器堆有一个特殊位置，0号地址永远不会被实际写入数据，总是保持0值。

#### 规格

Table: 寄存器堆规格

| 寄存器堆    | 容量  | 位宽    | 读口数量  | 写口数量  | 分块数量  |
| ---------- | ----- | ------- | -------- | -------- | -------- |
| IntRegFile | 224   |  64-bit |  11      |   8      |   4      |
| FpRegFile  | 192   |  64-bit |  11      |   6      |   4      |
| VfRegFile  | 128   | 128-bit |  12      |   6      |   4      |
| V0RegFile  |  22   | 128-bit |   4      |   6      |   2      |
| VlRegFile  |  32   |   8-bit |   4      |   4      |   1      |


### 二级模块 RegCache

#### 功能


#### 整体框图


#### 接口列表

见接口文档
