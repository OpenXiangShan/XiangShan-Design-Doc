# BPU 子模块 ITTAGE

## 功能

ITTAGE 接收来自 BPU 内部的预测请求，其内部由一个基预测表和多个历史表组成，每个表项中都有一个用于存储间接跳转指令目标地址的 字段。基预测表用 PC 索引，而历史表用 PC 和一定长度的分支历史折叠后的结果异或索引，不同历史表使用的分支历史长度不同。在预测时，还会用 PC 和每个历史表对应的分支历史的另一种折叠结果异或计算 tag，与表中读出的 tag 进行匹配，如果匹配成功则该表命中。最终的结果取决于命中的历史长度最长的预测表的结果。最终，ITTAGE 将预测结果输出至 composer。

### 间接跳转指令的预测

ITTAGE 用于预测间接跳转指令。普通分支指令和无条件跳转指令的跳转目标直接编码于指令中，便于预测，而间接跳转指令的跳转地址来自运行时可变的寄存器，从而有多种可能选择，需要根据分支历史对其作出预测。

为此，ITTAGE 的每个表项在 TAGE 表项的基础上加入了所预测的跳转地址项，最后输出结果为选出的命中预测跳转地址而非选出的跳转方 向。

由于每个 FTB 项仅存储至多一条间接跳转指令信息，ITTAGE 预测器每周期也最多预测一条间接跳转指令的目标地址。

香山南湖架构中的 ITTAGE 提供了 5 个带 tag 的预测表 T1-T5，基准预测器和带 tag 的预测表的基本信息见下表。

| **预测器**    | **是否带 tag** | **作用**                                         | **表项构成**                                                                                                   | **项数**                        |
| ------------- | -------------- | ------------------------------------------------ | -------------------------------------------------------------------------------------------------------------- | ------------------------------- |
| 基准预测器 T0 | 否             | 用于在带 tag 预测表的 tag 均不匹配时提供预测结果 | ITTAGE 中并没有实现 T0，而是直接使用 ftb 的预测结果作为基准预测结果                                            |                                 |
| 预测表 T1-T5  | 是             | 存在 tag 匹配时，选历史长度最长者提供预测结果    | valid 1bittag 9bitsctr 2bits（最高位表示要不要输出这 个预测结果 ）us: 1bit（usefulness 计数器）target：39 bits | T1-T2 各 256 项 T3-T5 各 512 项 |

在 BPU 模块中维护了一个 256 比特的全局分支历史 ghv，并为 ITTAGE 的 5 个带 tag 的预测表分别维护了各自的折叠分支历史，折叠算法同 TAGE 。折叠历史具体配置见下表，其中 ghv 是一个循环队列，"低"n 位指的是从 ptr 指示的位置算起的低位：

| **历史**            | **index 折叠分支历史长度** | **tag 折叠分支历史 1 长度** | **tag 折叠分支历史 2 长度** | **设计原理**                    |
| ------------------- | -------------------------- | --------------------------- | --------------------------- | ------------------------------- |
| 全局分支历史 ghv    | 256 比特                   | 无                          | 无                          | 每比特代表对应分支跳转与否      |
| T1 对应折叠分支历史 | 4 比特                     | 4 比特                      | 4 比特                      | ghv 取 ptr 起低 4 比特折叠异或  |
| T2 对应折叠分支历史 | 8 比特                     | 8 比特                      | 8 比特                      | ghv 取 ptr 起低 8 比特折叠异或  |
| T3 对应折叠分支历史 | 9 比特                     | 9 比特                      | 8 比特                      | ghv 取 ptr 起低 13 比特折叠异或 |
| T4 对应折叠分支历史 | 9 比特                     | 9 比特                      | 8 比特                      | ghv 取 ptr 起低 16 比特折叠异或 |
| T5 对应折叠分支历史 | 9 比特                     | 9 比特                      | 8 比特                      | ghv 取 ptr 起低 32 比特折叠异或 |

ITTAGE 需要 3 拍延迟：

* 0 拍生成寻址 index
* 1 拍读出数据
* 2 拍选出命中结果
* 3 拍输出

  ### Wrbypass

Wrbypass 里面有 Mem，也有 Cam，用于给更新做定序，每次 ITTAGE 更新时都会写进这个 wrbypass，同时写进对应预测表的 sram。每次更新的时候会查这个 wrbypass，如果 hit 了，那就把读出的 ITTAGE 的 ctr 值作为旧值，之前随 branch 指令带到后端再送回前端的 ctr 旧值就不要了 。这样如果一个分支重复更新，那 wrbypass 可以保证某一次更新一定能拿到相邻的上一次更新的最终值。

ITTAGE 的每一个预测表 T1~T5 都有着一个对应的 wrbypass，每个预测表的 wrbypass 中，Mem 都有 4 个 entry，每个 entry 存储 1 个 ctr；Cam 有 4 个 entry，输入更新的 idx 和 tag 就可以读到对应数据在 Cam 中的位置。Cam 和 Mem 是同时写的，所以数据在 Cam 中的位置就是在 Mem 中的位置。于是利用这个 Cam，我们就可以在更新的时候查看对应 idx 的数据是否在 wrbypass 中。

#### 预测器训练

首先，定义所有产生 tag 匹配的预测表中所需历史长度最长者为 provider，而其余匹配的预测表（若存在的话）被称为 altpred。 当 provider 的 ctr 为 0 时，会选择 altpred 的结果作为预测结果。

ITTAGE 表项中包含一个 usefulness 域，当 provider 预测正确而 altpred 预测错误时 provider 的 usefulness 置 1，表示该项是一个有用的项，便不会被训练时的分配算法当作空项分配出去。当 provider 产生的预测被证实为一个正确的预测，且此时的 provider 与 altpred 的预测结 果不同，则 provider 的 usefulness 域被置
若预测地址与实际一致，则将对应 provider 表项的 ctr 计数器自增 1；若预测地址与实际不一致，则将对应 provider 表项的 ctr 计数器自减 1。ITTAGE 中，会根据 ctr 判断是否采取这个预测的跳转目标结果。当 ctr 为 0 时，会选择 altpred 的结果。

接下来，若该 provider 所源自的预测表并非所需历史长度最高的预测表，则此时执行如下的表项增添操作。表项增添操作会首先读取所有历史长度长于 provider 的预测表的 usefulness 域。若此时有某表的 usefulness 域值为 0，则在该表中分配一对应的表项；若没有找到满足 usefulness 域值为 0 的表，则分配失败。当有多个预测表（如 Tj,Tk 两项）的 usefulness 域均为 0 时，表项的分配概率是随机的，分配的时 候随机把某些 table 给 mask 掉，让它不会每次都分配同一个。这里的表项分配的随机性是通过 chisel 的 util 包里的 64 位线性反馈移位寄存 器原语 LFSR64 生成伪随机数来实现的，在 verilog 代码中对应 allocLFSR_lfsr 寄存器。在训练时，用 8 位 饱和计数器 tickCtr 统计分配失败次数-成功次数，当分配失败的次数足够多，tickCtr 计数器计数到满达到饱和时，触发全局 useful bit reset，把所有的 usefulness 域清零。

注：ITTAGE 的清零 usefulness 域的饱和计数器名字是 tickCtr，长度为 8 比特，名字和长度均与 TAGE 不同。

最后，在初始化时/TAGE 表分配新项时，所有的表项中的 ctr 计数器均被设置为 0，所有的 usefulness 域均被设置为 0。

## 存储结构

* 5 张历史表，项数分别为 256、256、512、512、512，每张表根据 pc 低位分了共 2 个 bank，每个 bank 有 128 个 set，每个 set 对应一个 FTB 项的最多 1 条间接跳转。
* 每个表项含有 1bit valid，9bit tag，2bit ctr，39bit target，1bit useful；其中 useful bit 独立存储，valid 使用寄存器堆独立存储
* 以 FTB 结果作为 base table，等效于 2K 项（但 FTB target 位宽不够，无法有效存储远跳转地址）
* 历史表每个 bank 有 4 项的写缓存 wrbypass

## 索引方式

* index = pc[8:1] ^ folded_hist(8bit) 或 pc 和 folded_hist 各 9bit
* tag = pc[17:9]（或 pc[19:10]） ^ folded_hist(9bit) ^ (folded_hist(8bit) << 1)
  * 此处大概还是应该用 pc 低位比较好，而不是用 index 没用过的另一段 pc，或者
* 历史采取基本的分段异或折叠

## 预测流程

* s0 进行索引计算，地址送入 SRAM
* s1 读出表项，进行 bank 选取，以及判断是否命中，结果寄存到 s2
* s2 计算最长历史匹配和次长历史匹配：
  * 当存在历史表命中，且 ctr!=0 的时候，尝试使用最长历史结果目标地址
  * 当 provider 信心不足（ctr==0）时，若次长历史命中，尝试使用次长历史结果目标地址
  * 当没有历史表命中的时候，使用 FTB 结果
  * 尝试使用历史表的结果时，只有 ctr>1 才会真正使用，若 ctr<=1，则不使用结果
* s3 使用目标地址，在 BPU 内和 s2 结果进行比对，判断是否需要冲刷流水线

## 训练流程

基本和 TAGE 相同，对于 target 字段，仅当分配新表项或者原 ctr 为最小值 0 时，才会替换新值，否则保持原样
